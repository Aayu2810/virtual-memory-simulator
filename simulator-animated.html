<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Memory Simulator - Animated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: white;
        }

        /* Animated Background */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            overflow: hidden;
        }

        .floating-shape {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            animation: float 20s infinite ease-in-out;
        }

        .shape1 {
            width: 300px;
            height: 300px;
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .shape2 {
            width: 200px;
            height: 200px;
            top: 60%;
            right: 10%;
            animation-delay: 5s;
        }

        .shape3 {
            width: 250px;
            height: 250px;
            bottom: 10%;
            left: 50%;
            animation-delay: 10s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0) translateX(0) scale(1);
            }
            25% {
                transform: translateY(-50px) translateX(30px) scale(1.1);
            }
            50% {
                transform: translateY(-100px) translateX(-30px) scale(0.9);
            }
            75% {
                transform: translateY(-50px) translateX(30px) scale(1.1);
            }
        }

        /* Main Container */
        .main-container {
            position: relative;
            z-index: 1;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header with Animation */
        .header {
            text-align: center;
            padding: 40px 20px;
            animation: slideDown 1s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header h1 {
            font-size: 3.5em;
            margin-bottom: 10px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #fff, #a8dadc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
            }
            to {
                filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.9));
            }
        }

        .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
        }

        /* Control Panel with Glass Effect */
        .control-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            animation: fadeIn 1s ease-out 0.3s both;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .input-group {
            animation: slideInLeft 0.8s ease-out;
        }

        .input-group:nth-child(2) {
            animation-delay: 0.1s;
        }

        .input-group:nth-child(3) {
            animation-delay: 0.2s;
        }

        .input-group:nth-child(4) {
            animation-delay: 0.3s;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .input-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 1em;
        }

        input, select {
            width: 100%;
            padding: 12px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #a8dadc;
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.02);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        select option {
            background: #667eea;
            color: white;
        }

        /* Animated Buttons */
        .button-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 15px 35px;
            border-radius: 50px;
            border: none;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn span {
            position: relative;
            z-index: 1;
        }

        .btn-primary {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            color: white;
            box-shadow: 0 5px 15px rgba(0, 210, 255, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 210, 255, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.4);
        }

        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(240, 147, 251, 0.6);
        }

        .btn-success {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .btn-success:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.6);
        }

        .btn-danger {
            background: linear-gradient(45deg, #fa709a, #fee140);
            color: white;
            box-shadow: 0 5px 15px rgba(250, 112, 154, 0.4);
        }

        .btn-danger:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(250, 112, 154, 0.6);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Memory Display with 3D Effect */
        .memory-section {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            animation: fadeIn 1s ease-out 0.6s both;
        }

        .section-title {
            font-size: 2em;
            margin-bottom: 25px;
            text-align: center;
            position: relative;
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #a8dadc, transparent);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            perspective: 1000px;
        }

        .memory-frame {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 20px;
            padding: 30px 20px;
            text-align: center;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform-style: preserve-3d;
            cursor: pointer;
            min-height: 140px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .memory-frame:hover {
            transform: rotateY(10deg) scale(1.05);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }

        .memory-frame.occupied {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            border-color: #38ef7d;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(56, 239, 125, 0.5);
            }
            50% {
                box-shadow: 0 0 40px rgba(56, 239, 125, 0.8);
            }
        }

        .memory-frame.hit {
            animation: hitFlash 0.8s ease-out;
        }

        @keyframes hitFlash {
            0% {
                transform: scale(1);
                background: linear-gradient(135deg, #11998e, #38ef7d);
            }
            50% {
                transform: scale(1.2) rotate(5deg);
                background: linear-gradient(135deg, #4fc3f7, #00d2ff);
                box-shadow: 0 0 50px rgba(79, 195, 247, 1);
            }
            100% {
                transform: scale(1);
                background: linear-gradient(135deg, #11998e, #38ef7d);
            }
        }

        .memory-frame.fault {
            animation: faultShake 0.8s ease-out;
        }

        @keyframes faultShake {
            0%, 100% {
                transform: translateX(0) scale(1);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: translateX(-10px) scale(1.1);
                background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
                box-shadow: 0 0 50px rgba(255, 107, 107, 1);
            }
            20%, 40%, 60%, 80% {
                transform: translateX(10px) scale(1.1);
            }
        }

        .frame-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .frame-content {
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Stats Dashboard */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            animation: fadeIn 1s ease-out 0.9s both;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }

        .stat-value {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(45deg, #00d2ff, #a8dadc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: countUp 1s ease-out;
        }

        @keyframes countUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .stat-label {
            font-size: 1.1em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Page Table with Flip Animation */
        .page-table-section {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            max-height: 500px;
            overflow-y: auto;
        }

        .page-entry {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
            margin: 10px 0;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            transition: all 0.4s ease;
            animation: slideInRight 0.5s ease-out;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .page-entry:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(10px);
        }

        .page-entry.valid {
            background: linear-gradient(90deg, rgba(56, 239, 125, 0.3), rgba(17, 153, 142, 0.3));
            border-left: 5px solid #38ef7d;
        }

        /* Execution Log with Typewriter Effect */
        .log-section {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .log-entry {
            padding: 12px;
            margin: 5px 0;
            border-left: 4px solid transparent;
            border-radius: 5px;
            animation: typewriter 0.5s ease-out;
        }

        @keyframes typewriter {
            from {
                opacity: 0;
                max-width: 0;
            }
            to {
                opacity: 1;
                max-width: 100%;
            }
        }

        .log-entry.hit {
            border-left-color: #38ef7d;
            background: rgba(56, 239, 125, 0.2);
            color: #38ef7d;
        }

        .log-entry.fault {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .log-entry.info {
            border-left-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.2);
            color: #4fc3f7;
        }

        /* Reference String Progress Bar */
        .progress-bar-container {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .reference-progress {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .ref-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px 20px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2em;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .ref-item.current {
            background: linear-gradient(135deg, #4fc3f7, #00d2ff);
            transform: scale(1.3) rotate(5deg);
            box-shadow: 0 10px 30px rgba(79, 195, 247, 0.6);
            animation: bounce 0.6s ease-in-out;
        }

        @keyframes bounce {
            0%, 100% {
                transform: scale(1.3) rotate(5deg) translateY(0);
            }
            50% {
                transform: scale(1.3) rotate(5deg) translateY(-20px);
            }
        }

        .ref-item.completed {
            background: linear-gradient(135deg, #38ef7d, #11998e);
            opacity: 0.7;
            transform: scale(0.9);
        }

        /* Loading Animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(102, 126, 234, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loader {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #00d2ff, #3a7bd5);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #3a7bd5, #00d2ff);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5em;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .memory-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }

            .button-container {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .stats-dashboard {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <!-- Animated Background -->
    <div class="animated-bg">
        <div class="floating-shape shape1"></div>
        <div class="floating-shape shape2"></div>
        <div class="floating-shape shape3"></div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loader"></div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <h1>üíæ Virtual Memory Simulator</h1>
            <p class="subtitle">Interactive Page Replacement Animation</p>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="controls-grid">
                <div class="input-group">
                    <label>üî¢ Number of Frames</label>
                    <input type="number" id="numFrames" value="4" min="2" max="10">
                </div>
                <div class="input-group">
                    <label>üìù Page Reference String</label>
                    <input type="text" id="referenceString" placeholder="e.g., 7,0,1,2,0,3,0,4" value="7,0,1,2,0,3,0,4,2,3,0,3,2">
                </div>
                <div class="input-group">
                    <label>‚öôÔ∏è Algorithm</label>
                    <select id="algorithm">
                        <option value="fifo">FIFO (First-In-First-Out)</option>
                        <option value="lru">LRU (Least Recently Used)</option>
                        <option value="optimal">Optimal (B√©l√°dy's)</option>
                        <option value="lfu">LFU (Least Frequently Used)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>‚ö° Speed: <span id="speedDisplay">1000ms</span></label>
                    <input type="range" id="speedSlider" min="200" max="2000" value="1000" step="100">
                </div>
            </div>

            <div class="button-container">
                <button class="btn btn-primary" onclick="startSimulation()">
                    <span>‚ñ∂Ô∏è Start Simulation</span>
                </button>
                <button class="btn btn-secondary" id="pauseBtn" onclick="pauseSimulation()" disabled>
                    <span>‚è∏Ô∏è Pause</span>
                </button>
                <button class="btn btn-success" id="stepBtn" onclick="stepForward()" disabled>
                    <span>‚è≠Ô∏è Step Forward</span>
                </button>
                <button class="btn btn-danger" onclick="resetSimulation()">
                    <span>üîÑ Reset</span>
                </button>
            </div>
        </div>

        <!-- Stats Dashboard -->
        <div class="stats-dashboard">
            <div class="stat-card">
                <div class="stat-value" id="pageFaults">0</div>
                <div class="stat-label">Page Faults</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="pageHits">0</div>
                <div class="stat-label">Page Hits</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="hitRatio">0%</div>
                <div class="stat-label">Hit Ratio</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="currentPage">-</div>
                <div class="stat-label">Current Page</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="progress">0%</div>
                <div class="stat-label">Progress</div>
            </div>
        </div>

        <!-- Memory Frames -->
        <div class="memory-section">
            <h2 class="section-title">üóÑÔ∏è Physical Memory (Page Frames)</h2>
            <div class="memory-grid" id="memoryGrid"></div>
        </div>

        <!-- Reference String Progress -->
        <div class="progress-bar-container">
            <h2 class="section-title">üìç Reference String Progress</h2>
            <div class="reference-progress" id="referenceProgress"></div>
        </div>

        <!-- Page Table -->
        <div class="page-table-section">
            <h2 class="section-title">üìã Page Table</h2>
            <div id="pageTable"></div>
        </div>

        <!-- Execution Log -->
        <div class="log-section">
            <h2 class="section-title">üìù Execution Log</h2>
            <div id="executionLog"></div>
        </div>
    </div>

    <script>
        // ================================================
        // PAGE REPLACEMENT ALGORITHMS
        // ================================================

        function fifoAlgorithm(referenceString, numFrames) {
            let frames = new Array(numFrames).fill(null);
            let pageFaults = 0;
            let pageHits = 0;
            let queue = [];
            let steps = [];

            referenceString.forEach((page, index) => {
                const frameIndex = frames.indexOf(page);
                
                if (frameIndex !== -1) {
                    pageHits++;
                    steps.push({
                        step: index + 1,
                        page: page,
                        frames: [...frames],
                        type: 'hit',
                        message: `[Step ${index + 1}] Page ${page} found in Frame ${frameIndex} (HIT)`
                    });
                } else {
                    pageFaults++;
                    const emptyFrame = frames.indexOf(null);
                    
                    if (emptyFrame !== -1) {
                        frames[emptyFrame] = page;
                        queue.push(emptyFrame);
                        steps.push({
                            step: index + 1,
                            page: page,
                            frames: [...frames],
                            type: 'fault',
                            message: `[Step ${index + 1}] Page ${page} loaded into Frame ${emptyFrame} (FAULT - Empty frame)`
                        });
                    } else {
                        const replaceFrame = queue.shift();
                        const oldPage = frames[replaceFrame];
                        frames[replaceFrame] = page;
                        queue.push(replaceFrame);
                        steps.push({
                            step: index + 1,
                            page: page,
                            frames: [...frames],
                            type: 'fault',
                            message: `[Step ${index + 1}] Page ${page} replaced Page ${oldPage} in Frame ${replaceFrame} (FAULT - FIFO)`
                        });
                    }
                }
            });

            return { pageFaults, pageHits, steps };
        }

        function lruAlgorithm(referenceString, numFrames) {
            let frames = new Array(numFrames).fill(null);
            let pageFaults = 0;
            let pageHits = 0;
            let timestamps = {};
            let steps = [];

            referenceString.forEach((page, index) => {
                const frameIndex = frames.indexOf(page);
            if (frameIndex !== -1) {
                pageHits++;
                timestamps[page] = index;
                steps.push({
                    step: index + 1,
                    page: page,
                    frames: [...frames],
                    type: 'hit',
                    message: `[Step ${index + 1}] Page ${page} found in Frame ${frameIndex} (HIT)`
                });
            } else {
                pageFaults++;
                timestamps[page] = index;
                const emptyFrame = frames.indexOf(null);
                
                if (emptyFrame !== -1) {
                    frames[emptyFrame] = page;
                    steps.push({
                        step: index + 1,
                        page: page,
                        frames: [...frames],
                        type: 'fault',
                        message: `[Step ${index + 1}] Page ${page} loaded into Frame ${emptyFrame} (FAULT - Empty frame)`
                    });
                } else {
                    let lruPage = frames[0];
                    let lruTime = timestamps[lruPage];
                    
                    for (let i = 1; i < frames.length; i++) {
                        if (timestamps[frames[i]] < lruTime) {
                            lruPage = frames[i];
                            lruTime = timestamps[frames[i]];
                        }
                    }
                    
                    const replaceFrame = frames.indexOf(lruPage);
                    frames[replaceFrame] = page;
                    steps.push({
                        step: index + 1,
                        page: page,
                        frames: [...frames],
                        type: 'fault',
                        message: `[Step ${index + 1}] Page ${page} replaced Page ${lruPage} in Frame ${replaceFrame} (FAULT - LRU)`
                    });
                }
            }
        });

        return { pageFaults, pageHits, steps };
    }

    function optimalAlgorithm(referenceString, numFrames) {
        let frames = new Array(numFrames).fill(null);
        let pageFaults = 0;
        let pageHits = 0;
        let steps = [];

        referenceString.forEach((page, index) => {
            const frameIndex = frames.indexOf(page);
            
            if (frameIndex !== -1) {
                pageHits++;
                steps.push({
                    step: index + 1,
                    page: page,
                    frames: [...frames],
                    type: 'hit',
                    message: `[Step ${index + 1}] Page ${page} found in Frame ${frameIndex} (HIT)`
                });
            } else {
                pageFaults++;
                const emptyFrame = frames.indexOf(null);
                
                if (emptyFrame !== -1) {
                    frames[emptyFrame] = page;
                    steps.push({
                        step: index + 1,
                        page: page,
                        frames: [...frames],
                        type: 'fault',
                        message: `[Step ${index + 1}] Page ${page} loaded into Frame ${emptyFrame} (FAULT - Empty frame)`
                    });
                } else {
                    let farthest = -1;
                    let replaceFrame = 0;
                    
                    for (let i = 0; i < frames.length; i++) {
                        let j;
                        for (j = index + 1; j < referenceString.length; j++) {
                            if (frames[i] === referenceString[j]) {
                                if (j > farthest) {
                                    farthest = j;
                                    replaceFrame = i;
                                }
                                break;
                            }
                        }
                        if (j === referenceString.length) {
                            replaceFrame = i;
                            break;
                        }
                    }
                    
                    const oldPage = frames[replaceFrame];
                    frames[replaceFrame] = page;
                    steps.push({
                        step: index + 1,
                        page: page,
                        frames: [...frames],
                        type: 'fault',
                        message: `[Step ${index + 1}] Page ${page} replaced Page ${oldPage} in Frame ${replaceFrame} (FAULT - Optimal)`
                    });
                }
            }
        });

        return { pageFaults, pageHits, steps };
    }

    function lfuAlgorithm(referenceString, numFrames) {
        let frames = new Array(numFrames).fill(null);
        let pageFaults = 0;
        let pageHits = 0;
        let counts = {};
        let steps = [];

        referenceString.forEach((page, index) => {
            const frameIndex = frames.indexOf(page);
            
            if (frameIndex !== -1) {
                pageHits++;
                counts[page] = (counts[page] || 0) + 1;
                steps.push({
                    step: index + 1,
                    page: page,
                    frames: [...frames],
                    type: 'hit',
                    message: `[Step ${index + 1}] Page ${page} found in Frame ${frameIndex} (HIT, count: ${counts[page]})`
                });
            } else {
                pageFaults++;
                counts[page] = 1;
                const emptyFrame = frames.indexOf(null);
                
                if (emptyFrame !== -1) {
                    frames[emptyFrame] = page;
                    steps.push({
                        step: index + 1,
                        page: page,
                        frames: [...frames],
                        type: 'fault',
                        message: `[Step ${index + 1}] Page ${page} loaded into Frame ${emptyFrame} (FAULT - Empty frame)`
                    });
                } else {
                    let lfuPage = frames[0];
                    let lfuCount = counts[lfuPage];
                    
                    for (let i = 1; i < frames.length; i++) {
                        if (counts[frames[i]] < lfuCount) {
                            lfuPage = frames[i];
                            lfuCount = counts[frames[i]];
                        }
                    }
                    
                    const replaceFrame = frames.indexOf(lfuPage);
                    frames[replaceFrame] = page;
                    steps.push({
                        step: index + 1,
                        page: page,
                        frames: [...frames],
                        type: 'fault',
                        message: `[Step ${index + 1}] Page ${page} replaced Page ${lfuPage} (count: ${lfuCount}) in Frame ${replaceFrame} (FAULT - LFU)`
                    });
                }
            }
        });

        return { pageFaults, pageHits, steps };
    }

    // ================================================
    // SIMULATION LOGIC
    // ================================================

    let state = {
        frames: [],
        referenceString: [],
        currentStep: 0,
        pageFaults: 0,
        pageHits: 0,
        isRunning: false,
        isPaused: false,
        speed: 1000,
        steps: []
    };

    document.addEventListener('DOMContentLoaded', function() {
        initializeSimulator();
        
        document.getElementById('speedSlider').addEventListener('input', function() {
            state.speed = parseInt(this.value);
            document.getElementById('speedDisplay').textContent = this.value + 'ms';
        });
    });

    function initializeSimulator() {
        const numFrames = parseInt(document.getElementById('numFrames').value);
        state.frames = new Array(numFrames).fill(null);
        
        const grid = document.getElementById('memoryGrid');
        grid.innerHTML = '';
        for (let i = 0; i < numFrames; i++) {
            const frame = document.createElement('div');
            frame.className = 'memory-frame';
            frame.id = `frame-${i}`;
            frame.innerHTML = `
                <div class="frame-label">FRAME ${i}</div>
                <div class="frame-content">-</div>
            `;
            grid.appendChild(frame);
        }
    }

    function startSimulation() {
        const refString = document.getElementById('referenceString').value;
        if (!refString.trim()) {
            alert('Please enter a page reference string!');
            return;
        }

        const refs = refString.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
        if (refs.length === 0) {
            alert('Invalid reference string!');
            return;
        }

        const numFrames = parseInt(document.getElementById('numFrames').value);
        const algorithm = document.getElementById('algorithm').value;
        
        state.referenceString = refs;
        state.currentStep = 0;
        state.pageFaults = 0;
        state.pageHits = 0;
        state.isRunning = true;
        state.isPaused = false;

        const result = getAlgorithmSteps(algorithm, refs, numFrames);
        state.steps = result.steps;

        initializeSimulator();
        document.getElementById('executionLog').innerHTML = '';
        
        document.getElementById('loadingOverlay').classList.add('active');
        setTimeout(() => {
            document.getElementById('loadingOverlay').classList.remove('active');
            runSimulation();
        }, 1000);

        document.getElementById('pauseBtn').disabled = false;
        document.getElementById('stepBtn').disabled = false;
    }

    async function runSimulation() {
        while (state.currentStep < state.steps.length && state.isRunning && !state.isPaused) {
            await executeStep();
            await sleep(state.speed);
        }
    }

    async function executeStep() {
        if (state.currentStep >= state.steps.length) return;

        const step = state.steps[state.currentStep];
        
        if (step.type === 'hit') state.pageHits++;
        else state.pageFaults++;

        updateMemory(step.frames, step.type, step.page);
        updateStats();
        updatePageTable(step.frames);
        updateReferenceProgress(state.currentStep);
        addLog(step.message, step.type);

        state.currentStep++;
    }

    function updateMemory(frames, type, page) {
        frames.forEach((p, index) => {
            const frame = document.getElementById(`frame-${index}`);
            const content = frame.querySelector('.frame-content');
            content.textContent = p !== null ? p : '-';
            
            frame.classList.remove('occupied', 'hit', 'fault');
            if (p !== null) {
                frame.classList.add('occupied');
                if (p === page) {
                    frame.classList.add(type);
                }
            }
        });
    }

    function updateStats() {
        document.getElementById('pageFaults').textContent = state.pageFaults;
        document.getElementById('pageHits').textContent = state.pageHits;
        
        const total = state.pageFaults + state.pageHits;
        const ratio = total > 0 ? ((state.pageHits / total) * 100).toFixed(1) : 0;
        document.getElementById('hitRatio').textContent = ratio + '%';
        
        const currentPage = state.steps[state.currentStep - 1]?.page || '-';
        document.getElementById('currentPage').textContent = currentPage;
        
        const progress = ((state.currentStep / state.steps.length) * 100).toFixed(0);
        document.getElementById('progress').textContent = progress + '%';
    }

    function updatePageTable(frames) {
        const container = document.getElementById('pageTable');
        container.innerHTML = '';
        
        const uniquePages = [...new Set(state.referenceString)].sort((a, b) => a - b);
        
        uniquePages.forEach(page => {
            const frameNum = frames.indexOf(page);
            const isValid = frameNum !== -1;
            
            const entry = document.createElement('div');
            entry.className = `page-entry ${isValid ? 'valid' : ''}`;
            entry.innerHTML = `
                <div><strong>Page ${page}</strong></div>
                <div>Frame: ${isValid ? frameNum : '-'}</div>
                <div>${isValid ? '‚úÖ Valid' : '‚ùå Invalid'}</div>
            `;
            container.appendChild(entry);
        });
    }

    function updateReferenceProgress(current) {
        const container = document.getElementById('referenceProgress');
        container.innerHTML = '';
        
        state.referenceString.forEach((page, index) => {
            const item = document.createElement('div');
            item.className = 'ref-item';
            item.textContent = page;
            
            if (index === current) item.classList.add('current');
            else if (index < current) item.classList.add('completed');
            
            container.appendChild(item);
        });
    }

    function addLog(message, type) {
        const log = document.getElementById('executionLog');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = message;
        log.insertBefore(entry, log.firstChild);
        
        while (log.children.length > 50) {
            log.removeChild(log.lastChild);
        }
    }

    function pauseSimulation() {
        state.isPaused = !state.isPaused;
        const btn = document.getElementById('pauseBtn');
        btn.querySelector('span').textContent = state.isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        
        if (!state.isPaused && state.isRunning) {
            runSimulation();
        }
    }

    async function stepForward() {
        if (!state.isRunning) {
            startSimulation();
            state.isPaused = true;
        }
        
        if (state.currentStep < state.steps.length) {
            await executeStep();
        }
    }

    function resetSimulation() {
        state.isRunning = false;
        state.isPaused = false;
        state.currentStep = 0;
        state.pageFaults = 0;
        state.pageHits = 0;
        
        initializeSimulator();
        document.getElementById('executionLog').innerHTML = '';
        document.getElementById('referenceProgress').innerHTML = '';
        document.getElementById('pageTable').innerHTML = '';
        updateStats();
        
        document.getElementById('pauseBtn').disabled = true;
        document.getElementById('stepBtn').disabled = true;
        document.getElementById('pauseBtn').querySelector('span').textContent = '‚è∏Ô∏è Pause';
    }

    function getAlgorithmSteps(algorithm, refs, numFrames) {
        switch(algorithm) {
            case 'fifo': return fifoAlgorithm(refs, numFrames);
            case 'lru': return lruAlgorithm(refs, numFrames);
            case 'optimal': return optimalAlgorithm(refs, numFrames);
            case 'lfu': return lfuAlgorithm(refs, numFrames);
            default: return fifoAlgorithm(refs, numFrames);
        }
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
</script>
